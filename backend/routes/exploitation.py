# backend/routes/exploitation.py
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel
import os, json, uuid, logging, time
from neo4j import GraphDatabase

from backend.tools.runner import run_tool_in_docker  # relative import

log = logging.getLogger("exploitation")

NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASS = os.getenv("NEO4J_PASS", "neo4jpass")

driver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASS))

router = APIRouter(prefix="/exploitation", tags=["exploitation"])

class SessionRequest(BaseModel):
    tool: str
    subcommand: str
    args: dict = {}
    target: str
    dry_run: bool = True

@router.get("/containers")
def list_containers(limit: int = 100):
    q = """
    MATCH (c:Container)
    RETURN c.container_id AS id, c.name AS name, c.image AS image, c.ip AS ip, c.ports AS ports, c.host AS host, c.last_seen AS last_seen
    ORDER BY c.last_seen DESC
    LIMIT $limit
    """
    with driver.session() as s:
        res = s.run(q, limit=limit)
        rows = [r.data() for r in res]
    return {"count": len(rows), "containers": rows}

def create_session_node(session_id, project_id, container_id, req: SessionRequest):
    with driver.session() as s:
        s.execute_write(
            lambda tx: tx.run(
                """
                CREATE (sess:Session {
                    session_id:$sid,
                    project_id:$pid,
                    container_id:$cid,
                    tool:$tool,
                    subcommand:$sub,
                    args:$args,
                    target:$target,
                    dry_run:$dry,
                    created_at:$now
                })
                """,
                sid=session_id,
                pid=project_id,
                cid=container_id,
                tool=req.tool,
                sub=req.subcommand,
                args=json.dumps(req.args),
                target=req.target,
                dry=req.dry_run,
                now=int(time.time() * 1000)
            )
        )

def update_session_result(session_id, exit_code, stdout, stderr):
    with driver.session() as s:
        s.execute_write(
            lambda tx: tx.run(
                """
                MATCH (s:Session {session_id:$sid})
                SET s.finished_at = $now, s.exit_code = $exit, s.stdout = $out, s.stderr = $err
                """,
                sid=session_id, now=int(time.time()*1000),
                exit=exit_code, out=stdout, err=stderr
            )
        )

@router.post("/projects/{project_id}/containers/{container_id}/sessions")
def create_session(project_id: str, container_id: str, req: SessionRequest, background_tasks: BackgroundTasks):
    # 1) lookup container record
    with driver.session() as s:
        r = s.execute_read(lambda tx: tx.run("MATCH (c:Container {container_id:$cid}) RETURN c LIMIT 1", cid=container_id).single())
        if not r:
            raise HTTPException(status_code=404, detail="container not found")
    session_id = f"sess-{uuid.uuid4().hex[:8]}"

    # 2) store session metadata (dry-run or real) into Neo4j for auditing
    create_session_node(session_id, project_id, container_id, req)

    # 3) Dry-run returns simulated output
    if req.dry_run:
        simulated = {
            "session_id": session_id,
            "stdout": f"[DRY-RUN] Would run {req.tool} {req.subcommand} with args {req.args} against {req.target}",
            "stderr": "",
            "exit_code": 0
        }
        # update session node with dry-run result (optional)
        update_session_result(session_id, 0, simulated["stdout"], simulated["stderr"])
        return {"status":"dry-run", "session": simulated}

    # 4) For real runs, schedule execution in background to avoid blocking the API
    #    Runner returns (exit_code, stdout, stderr)
    def _run_and_update():
        try:
            exit_code, stdout, stderr = run_tool_in_docker(req.tool, req.subcommand, req.args, req.target)
        except Exception as e:
            exit_code = 255
            stdout = ""
            stderr = str(e)
        update_session_result(session_id, exit_code, stdout, stderr)

    background_tasks.add_task(_run_and_update)
    return {"status":"queued", "session_id": session_id}
