"""
Abstract Base Class for Vulnerability Scanning Tools
Docker Exploit Mapper (DEM) - Subsystem 2
Team 16 - Date: 2025-10-27

This module defines the abstract base class VulnerabilityToolsHandler that all
vulnerability scanning tool implementations (e.g., Grype, Trivy) must extend.
This follows the Open/Closed Principle (OCP) and Dependency Inversion Principle (DIP)
by defining a common interface for vulnerability scanners.

"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
import logging
from pathlib import Path


class VulnerabilityToolsHandler(ABC):
    """
    Abstract base class for vulnerability scanning tool integrations.
    
    This class defines the contract that all vulnerability scanner implementations
    must follow. It provides common functionality like configuration and logging,
    while requiring subclasses to implement tool-specific scanning logic.
    
    Attributes:
        logger (logging.Logger): Logger instance for tracking operations
        config (Dict[str, Any]): Configuration parameters for the scanner
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        """
        Initialize the vulnerability tools handler.
        
        Args:
            config: Optional configuration dictionary for the scanner.
                   Can include settings like timeout, output format, etc.
        
        Postcondition:
            - Logger is initialized with the class name
            - Configuration is set (empty dict if None provided)
        """
        self.logger = logging.getLogger(self.__class__.__name__)
        self.config = config if config is not None else {}
        self.logger.info(f"Initialized {self.__class__.__name__} with config: {self.config}")
    
    @abstractmethod
    def execute_scan(
        self, 
        target: str, 
        additional_flags: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Execute a vulnerability scan on the specified target.
        
        This is an abstract method that must be implemented by subclasses
        to provide tool-specific scanning logic.
        
        Args:
            target: The scan target (e.g., container image name, file path)
            additional_flags: Optional list of tool-specific command-line flags
        
        Returns:
            Dictionary containing scan results with parsed vulnerability data
        
        Raises:
            NotImplementedError: If subclass doesn't implement this method
            ValueError: If target is invalid
            RuntimeError: If scan execution fails
        
        Preconditions:
            - target must be a non-empty string
            - additional_flags must be a list if provided
        
        Postconditions:
            - Returns a dictionary with at least 'status' and 'vulnerabilities' keys
            - Logs scan execution details
        """
        pass
    
    def configure_scan(self, **kwargs: Any) -> None:
        """
        Configure scanner settings with provided keyword arguments.
        
        This is a concrete method providing default configuration functionality.
        Subclasses can override this to add tool-specific configuration logic.
        
        Args:
            **kwargs: Arbitrary keyword arguments for configuration
                     (e.g., timeout=30, output_format='json', severity_threshold='high')
        
        Example:
            handler.configure_scan(timeout=60, output_format='json')
        
        Postcondition:
            - Configuration dictionary is updated with provided kwargs
            - Changes are logged
        """
        self.config.update(kwargs)
        self.logger.info(f"Updated configuration: {kwargs}")
    
    def validate_target(self, target: str) -> bool:
        """
        Validate that the scan target meets basic requirements.
        
        This is a concrete helper method that subclasses can use or override
        for target validation logic.
        
        Args:
            target: The scan target to validate
        
        Returns:
            True if target is valid, False otherwise
        
        Postcondition:
            - Returns boolean indicating validity
            - Logs validation result
        """
        if not target or not isinstance(target, str):
            self.logger.error(f"Invalid target: {target}")
            return False
        
        if not target.strip():
            self.logger.error("Target is empty or whitespace")
            return False
        
        self.logger.debug(f"Target validation passed: {target}")
        return True
    
    def get_config(self) -> Dict[str, Any]:
        """
        Retrieve the current configuration.
        
        Returns:
            Copy of the current configuration dictionary
        """
        return self.config.copy()
    
    def __repr__(self) -> str:
        """String representation of the handler for debugging."""
        return f"{self.__class__.__name__}(config={self.config})"

