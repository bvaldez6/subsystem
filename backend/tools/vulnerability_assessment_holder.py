"""
Vulnerability Assessment Holder (Repository Pattern)
Docker Exploit Mapper (DEM) - Subsystem 2
Team 16 - Date: 2025-10-27

This module implements the repository pattern for storing and retrieving
vulnerability assessments. Currently implemented as a stub with in-memory storage,
but designed to be extended with Neo4J database integration later.

Future Enhancement:
- Replace in-memory storage with Neo4J graph database
- Add relationship mapping between vulnerabilities and containers
- Implement query optimizations and indexing
"""

from typing import List, Dict, Any, Optional, Set
from datetime import datetime
import logging
from collections import defaultdict

from vulnerability import Vulnerability


class VulnerabilityAssessmentHolder:
    """
    Repository for storing and retrieving vulnerability assessment data.
    
    This class acts as a data access layer between the application logic
    and the underlying storage mechanism. Currently uses in-memory storage
    for development/testing, but designed to be replaced with Neo4J integration.
    
    Attributes:
        vulnerabilities (List[Vulnerability]): In-memory storage of vulnerabilities
        logger (logging.Logger): Logger for tracking operations
        _index_by_severity (Dict[str, List[Vulnerability]]): Index for fast severity lookups
        _index_by_package (Dict[str, List[Vulnerability]]): Index for fast package lookups
        _index_by_cve (Dict[str, Vulnerability]): Index for fast CVE ID lookups
    """
    
    def __init__(self) -> None:
        """
        Initialize the vulnerability assessment holder.
        
        Sets up in-memory storage structures and logging.
        
        Postcondition:
            - All storage structures are initialized
            - Logger is configured
        """
        self.vulnerabilities: List[Vulnerability] = []
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # Indexes for efficient querying (trade memory for speed)
        self._index_by_severity: Dict[str, List[Vulnerability]] = defaultdict(list)
        self._index_by_package: Dict[str, List[Vulnerability]] = defaultdict(list)
        self._index_by_cve: Dict[str, Vulnerability] = {}
        
        self.logger.info("Initialized VulnerabilityAssessmentHolder with in-memory storage")
    
    def add_vulnerability(self, vulnerability: Vulnerability) -> bool:
        """
        Add a single vulnerability to the repository.
        
        Args:
            vulnerability: Vulnerability instance to store
        
        Returns:
            True if added successfully, False if duplicate CVE ID exists
        
        Precondition:
            - vulnerability must be a valid Vulnerability instance
        
        Postcondition:
            - Vulnerability is stored if not duplicate
            - Indexes are updated
            - Operation is logged
        
        Example:
            vuln = Vulnerability(cve_id="CVE-2024-1234", ...)
            holder.add_vulnerability(vuln)
        """
        if not isinstance(vulnerability, Vulnerability):
            self.logger.error(f"Invalid vulnerability type: {type(vulnerability)}")
            return False
        
        # Check for duplicate CVE ID
        if vulnerability.cve_id in self._index_by_cve:
            self.logger.warning(
                f"Duplicate vulnerability detected: {vulnerability.cve_id}. Skipping."
            )
            return False
        
        # Add to main storage
        self.vulnerabilities.append(vulnerability)
        
        # Update indexes
        self._index_by_severity[vulnerability.severity].append(vulnerability)
        self._index_by_package[vulnerability.package].append(vulnerability)
        self._index_by_cve[vulnerability.cve_id] = vulnerability
        
        self.logger.debug(
            f"Added vulnerability: {vulnerability.cve_id} "
            f"(severity={vulnerability.severity}, package={vulnerability.package})"
        )
        
        return True
    
    def add_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> int:
        """
        Add multiple vulnerabilities to the repository in bulk.
        
        Args:
            vulnerabilities: List of Vulnerability instances to store
        
        Returns:
            Number of vulnerabilities successfully added (excludes duplicates)
        
        Postcondition:
            - All non-duplicate vulnerabilities are stored
            - Count of added vulnerabilities is returned
            - Operation is logged
        
        Example:
            count = holder.add_vulnerabilities([vuln1, vuln2, vuln3])
            print(f"Added {count} vulnerabilities")
        """
        added_count = 0
        for vuln in vulnerabilities:
            if self.add_vulnerability(vuln):
                added_count += 1
        
        self.logger.info(
            f"Bulk add completed: {added_count}/{len(vulnerabilities)} vulnerabilities added"
        )
        
        return added_count
    
    def get_vulnerabilities_by_severity(self, severity: str) -> List[Vulnerability]:
        """
        Retrieve all vulnerabilities matching a specific severity level.
        
        Args:
            severity: Severity level to filter by (Critical, High, Medium, Low, etc.)
        
        Returns:
            List of vulnerabilities with matching severity (empty list if none found)
        
        Example:
            critical_vulns = holder.get_vulnerabilities_by_severity("Critical")
            for vuln in critical_vulns:
                print(vuln.cve_id)
        
        Note:
            Uses indexed lookup for O(1) access time
        """
        results = self._index_by_severity.get(severity, [])
        self.logger.debug(f"Retrieved {len(results)} vulnerabilities with severity={severity}")
        return results.copy()  # Return copy to prevent external modification
    
    def get_vulnerabilities_by_package(self, package: str) -> List[Vulnerability]:
        """
        Retrieve all vulnerabilities affecting a specific package.
        
        Args:
            package: Package name to filter by (e.g., "openssl")
        
        Returns:
            List of vulnerabilities affecting the package (empty list if none found)
        
        Example:
            openssl_vulns = holder.get_vulnerabilities_by_package("openssl")
        
        Note:
            Uses indexed lookup for O(1) access time
        """
        results = self._index_by_package.get(package, [])
        self.logger.debug(f"Retrieved {len(results)} vulnerabilities for package={package}")
        return results.copy()
    
    def get_vulnerability_by_cve(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Retrieve a specific vulnerability by its CVE identifier.
        
        Args:
            cve_id: CVE identifier (e.g., "CVE-2024-1234")
        
        Returns:
            Vulnerability instance if found, None otherwise
        
        Example:
            vuln = holder.get_vulnerability_by_cve("CVE-2024-1234")
            if vuln:
                print(vuln.description)
        
        Note:
            Uses indexed lookup for O(1) access time
        """
        return self._index_by_cve.get(cve_id)
    
    def get_all_vulnerabilities(self) -> List[Vulnerability]:
        """
        Retrieve all stored vulnerabilities.
        
        Returns:
            Copy of all vulnerabilities in storage
        
        Example:
            all_vulns = holder.get_all_vulnerabilities()
            print(f"Total vulnerabilities: {len(all_vulns)}")
        """
        return self.vulnerabilities.copy()
    
    def get_vulnerability_count(self) -> int:
        """
        Get the total count of stored vulnerabilities.
        
        Returns:
            Number of vulnerabilities in storage
        """
        return len(self.vulnerabilities)
    
    def get_severity_distribution(self) -> Dict[str, int]:
        """
        Get distribution of vulnerabilities by severity level.
        
        Returns:
            Dictionary mapping severity levels to counts
        
        Example:
            distribution = holder.get_severity_distribution()
            # {"Critical": 5, "High": 12, "Medium": 8, "Low": 3}
        """
        distribution = {
            severity: len(vulns)
            for severity, vulns in self._index_by_severity.items()
        }
        self.logger.debug(f"Severity distribution: {distribution}")
        return distribution
    
    def get_package_distribution(self) -> Dict[str, int]:
        """
        Get distribution of vulnerabilities by affected package.
        
        Returns:
            Dictionary mapping package names to vulnerability counts
        
        Example:
            distribution = holder.get_package_distribution()
            # {"openssl": 5, "nginx": 3, "python": 2}
        """
        distribution = {
            package: len(vulns)
            for package, vulns in self._index_by_package.items()
        }
        return distribution
    
    def get_critical_and_high_vulnerabilities(self) -> List[Vulnerability]:
        """
        Retrieve all critical and high severity vulnerabilities.
        
        This is a convenience method for quickly identifying high-priority issues.
        
        Returns:
            Combined list of Critical and High severity vulnerabilities, sorted
        
        Example:
            high_priority = holder.get_critical_and_high_vulnerabilities()
            print(f"High priority issues: {len(high_priority)}")
        """
        critical = self.get_vulnerabilities_by_severity("Critical")
        high = self.get_vulnerabilities_by_severity("High")
        combined = critical + high
        combined.sort()  # Sort by severity and CVE ID
        return combined
    
    def filter_vulnerabilities(
        self,
        severity: Optional[str] = None,
        package: Optional[str] = None,
        min_cvss_score: Optional[float] = None,
        max_cvss_score: Optional[float] = None,
    ) -> List[Vulnerability]:
        """
        Filter vulnerabilities by multiple criteria.
        
        Args:
            severity: Filter by severity level (optional)
            package: Filter by package name (optional)
            min_cvss_score: Minimum CVSS score threshold (optional)
            max_cvss_score: Maximum CVSS score threshold (optional)
        
        Returns:
            List of vulnerabilities matching all provided criteria
        
        Example:
            # Find critical OpenSSL vulnerabilities with CVSS >= 7.0
            results = holder.filter_vulnerabilities(
                severity="Critical",
                package="openssl",
                min_cvss_score=7.0
            )
        """
        results = self.vulnerabilities
        
        # Apply severity filter
        if severity:
            results = [v for v in results if v.severity == severity]
        
        # Apply package filter
        if package:
            results = [v for v in results if v.package == package]
        
        # Apply CVSS score filters
        if min_cvss_score is not None:
            results = [
                v for v in results
                if v.cvss_score is not None and v.cvss_score >= min_cvss_score
            ]
        
        if max_cvss_score is not None:
            results = [
                v for v in results
                if v.cvss_score is not None and v.cvss_score <= max_cvss_score
            ]
        
        self.logger.debug(
            f"Filtered vulnerabilities: {len(results)} results "
            f"(severity={severity}, package={package}, "
            f"min_cvss={min_cvss_score}, max_cvss={max_cvss_score})"
        )
        
        return results
    
    def clear(self) -> None:
        """
        Clear all stored vulnerabilities and reset indexes.
        
        Warning: This operation cannot be undone. Use with caution.
        
        Postcondition:
            - All storage structures are empty
            - Operation is logged
        """
        count = len(self.vulnerabilities)
        self.vulnerabilities.clear()
        self._index_by_severity.clear()
        self._index_by_package.clear()
        self._index_by_cve.clear()
        
        self.logger.info(f"Cleared {count} vulnerabilities from storage")
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get comprehensive statistics about stored vulnerabilities.
        
        Returns:
            Dictionary containing various statistics and metrics
        
        Example:
            stats = holder.get_statistics()
            print(f"Total: {stats['total_count']}")
            print(f"Critical: {stats['severity_distribution']['Critical']}")
        """
        return {
            "total_count": self.get_vulnerability_count(),
            "severity_distribution": self.get_severity_distribution(),
            "package_distribution": self.get_package_distribution(),
            "unique_packages": len(self._index_by_package),
            "unique_cves": len(self._index_by_cve),
        }
    
    def __len__(self) -> int:
        """Support len() function."""
        return len(self.vulnerabilities)
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        return (
            f"VulnerabilityAssessmentHolder("
            f"vulnerabilities={len(self.vulnerabilities)}, "
            f"severity_levels={len(self._index_by_severity)}, "
            f"packages={len(self._index_by_package)})"
        )


# Stub Note for Future Development:
# TODO: Replace in-memory storage with Neo4J graph database integration
# TODO: Implement relationship mapping (Container -> Vulnerability -> Package)
# TODO: Add persistent storage with transaction support
# TODO: Implement caching layer for frequently accessed queries
# TODO: Add support for vulnerability lifecycle tracking (discovered, patched, etc.)

