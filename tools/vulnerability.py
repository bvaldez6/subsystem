"""
Vulnerability Data Model
Docker Exploit Mapper (DEM) - Subsystem 2
Team 16 - Date: 2025-10-27

This module defines the Vulnerability dataclass that represents a single
security vulnerability discovered during container image scanning. It follows
the Single Responsibility Principle by focusing solely on data representation.

"""

from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum


class Severity(Enum):
    """
    Enumeration of vulnerability severity levels.
    
    These levels follow the Common Vulnerability Scoring System (CVSS)
    and Grype's severity classification.
    """
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    NEGLIGIBLE = "Negligible"
    UNKNOWN = "Unknown"
    
    @classmethod
    def from_string(cls, severity_str: str) -> 'Severity':
        """
        Convert a string to a Severity enum value.
        
        Args:
            severity_str: String representation of severity
        
        Returns:
            Corresponding Severity enum value
        
        Example:
            Severity.from_string("high") -> Severity.HIGH
        """
        severity_map = {
            "critical": cls.CRITICAL,
            "high": cls.HIGH,
            "medium": cls.MEDIUM,
            "low": cls.LOW,
            "negligible": cls.NEGLIGIBLE,
            "unknown": cls.UNKNOWN,
        }
        return severity_map.get(severity_str.lower(), cls.UNKNOWN)


@dataclass(frozen=True)
class Vulnerability:
    """
    Immutable data class representing a security vulnerability.
    
    This class encapsulates all relevant information about a vulnerability
    discovered during a scan, including CVE identification, severity level,
    affected package, and remediation guidance.
    
    Attributes:
        cve_id (str): Common Vulnerabilities and Exposures identifier (e.g., "CVE-2024-1234")
        severity (str): Severity level (Critical, High, Medium, Low, Negligible, Unknown)
        description (str): Human-readable description of the vulnerability
        package (str): Name of the affected package (e.g., "openssl")
        remediation (str): Suggested fix or mitigation strategy
        package_version (Optional[str]): Version of the affected package
        fixed_version (Optional[str]): Version where the vulnerability is fixed
        cvss_score (Optional[float]): Common Vulnerability Scoring System score (0.0-10.0)
        discovered_at (datetime): Timestamp when vulnerability was discovered
        metadata (Dict[str, Any]): Additional metadata from the scanner
    
    Example:
        vuln = Vulnerability(
            cve_id="CVE-2024-1234",
            severity="High",
            description="Buffer overflow in OpenSSL",
            package="openssl",
            remediation="Upgrade to version 3.0.13",
            package_version="3.0.10",
            fixed_version="3.0.13",
            cvss_score=7.5
        )
    """
    
    # Required fields
    cve_id: str
    severity: str
    description: str
    package: str
    remediation: str
    
    # Optional fields with defaults
    package_version: Optional[str] = None
    fixed_version: Optional[str] = None
    cvss_score: Optional[float] = None
    discovered_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self) -> None:
        """
        Validate field values after initialization.
        
        This method is called automatically after __init__ by dataclass.
        It enforces invariants and data constraints.
        
        Raises:
            ValueError: If any field contains invalid data
        
        Preconditions:
            - cve_id must be non-empty string
            - severity must be valid severity level
            - cvss_score must be between 0.0 and 10.0 if provided
        """
        # Validate CVE ID format (basic check)
        if not self.cve_id or not isinstance(self.cve_id, str):
            raise ValueError(f"Invalid CVE ID: {self.cve_id}")
        
        # Validate severity
        valid_severities = {"Critical", "High", "Medium", "Low", "Negligible", "Unknown"}
        if self.severity not in valid_severities:
            raise ValueError(f"Invalid severity: {self.severity}. Must be one of {valid_severities}")
        
        # Validate CVSS score range
        if self.cvss_score is not None:
            if not (0.0 <= self.cvss_score <= 10.0):
                raise ValueError(f"CVSS score must be between 0.0 and 10.0, got {self.cvss_score}")
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the vulnerability to a dictionary representation.
        
        This is useful for JSON serialization, database storage, or API responses.
        
        Returns:
            Dictionary containing all vulnerability data
        
        Example:
            vuln_dict = vuln.to_dict()
            json.dumps(vuln_dict)  # Can be serialized to JSON
        """
        return {
            "cve_id": self.cve_id,
            "severity": self.severity,
            "description": self.description,
            "package": self.package,
            "remediation": self.remediation,
            "package_version": self.package_version,
            "fixed_version": self.fixed_version,
            "cvss_score": self.cvss_score,
            "discovered_at": self.discovered_at.isoformat() if self.discovered_at else None,
            "metadata": self.metadata,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Vulnerability':
        """
        Create a Vulnerability instance from a dictionary.
        
        This is useful for deserializing data from JSON, databases, or APIs.
        
        Args:
            data: Dictionary containing vulnerability data
        
        Returns:
            New Vulnerability instance
        
        Raises:
            KeyError: If required fields are missing
            ValueError: If field values are invalid
        
        Example:
            data = {"cve_id": "CVE-2024-1234", "severity": "High", ...}
            vuln = Vulnerability.from_dict(data)
        """
        # Parse discovered_at timestamp if present
        discovered_at = data.get("discovered_at")
        if discovered_at and isinstance(discovered_at, str):
            discovered_at = datetime.fromisoformat(discovered_at)
        elif not discovered_at:
            discovered_at = datetime.utcnow()
        
        return cls(
            cve_id=data["cve_id"],
            severity=data["severity"],
            description=data["description"],
            package=data["package"],
            remediation=data["remediation"],
            package_version=data.get("package_version"),
            fixed_version=data.get("fixed_version"),
            cvss_score=data.get("cvss_score"),
            discovered_at=discovered_at,
            metadata=data.get("metadata", {}),
        )
    
    def is_critical(self) -> bool:
        """Check if vulnerability is critical severity."""
        return self.severity == "Critical"
    
    def is_high_or_critical(self) -> bool:
        """Check if vulnerability is high or critical severity."""
        return self.severity in {"Critical", "High"}
    
    def get_severity_priority(self) -> int:
        """
        Get numeric priority for sorting vulnerabilities.
        
        Returns:
            Integer priority where higher numbers indicate more severe vulnerabilities
            (Critical=5, High=4, Medium=3, Low=2, Negligible=1, Unknown=0)
        """
        priority_map = {
            "Critical": 5,
            "High": 4,
            "Medium": 3,
            "Low": 2,
            "Negligible": 1,
            "Unknown": 0,
        }
        return priority_map.get(self.severity, 0)
    
    def __str__(self) -> str:
        """Human-readable string representation."""
        return (
            f"Vulnerability(cve_id={self.cve_id}, severity={self.severity}, "
            f"package={self.package}, version={self.package_version})"
        )
    
    def __lt__(self, other: 'Vulnerability') -> bool:
        """
        Enable sorting vulnerabilities by severity (highest first) then CVE ID.
        
        Args:
            other: Another Vulnerability instance to compare
        
        Returns:
            True if this vulnerability should be sorted before other
        """
        if not isinstance(other, Vulnerability):
            return NotImplemented
        
        # Sort by severity (descending) then CVE ID (ascending)
        if self.get_severity_priority() != other.get_severity_priority():
            return self.get_severity_priority() > other.get_severity_priority()
        return self.cve_id < other.cve_id

